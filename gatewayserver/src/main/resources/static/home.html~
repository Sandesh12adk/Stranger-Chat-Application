<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call Service</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #ff4757;
        }

        .status-dot.connected {
            background-color: #2ed573;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #ff9a9e, #fad0c4);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #333;
        }

        .video-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            height: 60vh;
        }

        .video-wrapper {
            position: relative;
            border-radius: 15px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .video-wrapper.local {
            border: 2px solid #2ed573;
        }

        .video-wrapper.remote {
            border: 2px solid #ffa502;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #000;
        }

        .video-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.6);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.4);
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.6);
        }

        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.4);
        }

        .btn-danger:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6);
        }

        .btn:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .connection-status {
            text-align: center;
            padding: 15px;
            font-size: 1.2rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
        }

        .waiting-animation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .dots {
            display: flex;
            gap: 5px;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: white;
            animation: pulse 1.5s infinite ease-in-out;
        }

        .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.3); opacity: 1; }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            border-left: 5px solid #2ed573;
        }

        .notification.error {
            border-left: 5px solid #ff4757;
        }

        .notification.info {
            border-left: 5px solid #3498db;
        }

        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 50vh;
            gap: 20px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .debug-info {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        @media (max-width: 768px) {
            .video-container {
                grid-template-columns: 1fr;
                height: auto;
            }

            .controls {
                flex-wrap: wrap;
            }

            .btn {
                flex: 1;
                min-width: 140px;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <h1>Video Call Service</h1>
        <p>Connect with people around the world through random video calls</p>
    </header>

    <div id="loading" class="loading-container">
        <div class="spinner"></div>
        <p>Checking authentication...</p>
    </div>

    <div id="mainContent" style="display: none;">
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="statusText">Connecting...</span>
            </div>
            <div class="user-info">
                <div class="avatar" id="userAvatar">U</div>
                <div>
                    <div id="userName">Loading...</div>
                    <div id="userId">ID: ...</div>
                </div>
            </div>
        </div>

        <div class="video-container">
            <div class="video-wrapper local">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-label">You</div>
            </div>
            <div class="video-wrapper remote">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="video-label">Partner</div>
            </div>
        </div>

        <div class="connection-status" id="connectionMessage">
            <div class="waiting-animation">
                <span>Looking for a partner</span>
                <div class="dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="nextBtn">
                <i>➡️</i> Next Partner
            </button>
            <button class="btn btn-danger" id="skipBtn" disabled>
                <i>⏹️</i> Skip
            </button>
        </div>
    </div>

    <!-- Debug Information -->
    <div id="debugInfo" class="debug-info" style="display: none;">
        <h3>Debug Information:</h3>
        <div id="debugContent"></div>
    </div>
</div>

<div class="notification" id="notification"></div>

<script>
    // Global variables
    let userId = null;
    let userName = null;
    let partnerId = null;
    let stompClient = null;
    let localStream = null;
    let remoteStream = null;
    let peerConnection = null;
    let isCaller = false;

    // Base URL configuration
    const BASE_URL = '/videocallservice';

    // DOM elements
    const loadingElement = document.getElementById('loading');
    const mainContent = document.getElementById('mainContent');
    const debugInfo = document.getElementById('debugInfo');
    const debugContent = document.getElementById('debugContent');
    const notification = document.getElementById('notification');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const connectionStatus = document.getElementById('connectionStatus');
    const statusText = document.getElementById('statusText');
    const connectionMessage = document.getElementById('connectionMessage');
    const nextBtn = document.getElementById('nextBtn');
    const skipBtn = document.getElementById('skipBtn');
    const userAvatar = document.getElementById('userAvatar');
    const userNameElement = document.getElementById('userName');
    const userIdElement = document.getElementById('userId');

    // WebRTC configuration
    const configuration = {
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' }
        ]
    };

    // Initialize the application
    document.addEventListener('DOMContentLoaded', async function() {
        debugInfo.style.display = 'block';
        addDebugInfo('Page loaded, starting authentication...');
        addDebugInfo(`Base URL configured as: ${BASE_URL}`);

        const authenticated = await getUserInfo();
        if (authenticated) {
            await initializeMedia();
            connectWebSocket();
            setupEventListeners();

            loadingElement.style.display = 'none';
            mainContent.style.display = 'block';
        }
    });

    // Debug function
    function addDebugInfo(message) {
        const timestamp = new Date().toLocaleTimeString();
        debugContent.innerHTML += `[${timestamp}] ${message}<br>`;
        debugContent.scrollTop = debugContent.scrollHeight;
        console.log(message);
    }

    // Get user information from session
    async function getUserInfo() {
        try {
            addDebugInfo('Fetching user session from /user/api/user/session-check');
            const response = await fetch('/user/api/user/session-check', {
                credentials: 'include'
            });

            addDebugInfo(`Session check response status: ${response.status}`);

            if (response.ok) {
                const userData = await response.json();
                userId = userData.userId;
                userName = userData.userName;

                // Update UI with user info
                userAvatar.textContent = userName.charAt(0).toUpperCase();
                userNameElement.textContent = userName;
                userIdElement.textContent = `ID: ${userId}`;

                addDebugInfo(`User authenticated: ${userName} (ID: ${userId})`);
                return true;
            } else if (response.status === 401) {
                addDebugInfo('User not authenticated, redirecting to signin');
                showNotification('Please sign in to continue', 'error');
                setTimeout(() => {
                    window.location.href = '/signin.html';
                }, 2000);
                return false;
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        } catch (error) {
            addDebugInfo(`Error getting user info: ${error.message}`);
            showNotification('Error: Could not retrieve user information', 'error');

            setTimeout(() => {
                window.location.href = '/signin.html';
            }, 3000);
            return false;
        }
    }

    // Initialize camera and microphone
    async function initializeMedia() {
        try {
            addDebugInfo('Requesting camera and microphone access');
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            localVideo.srcObject = localStream;
            addDebugInfo('Camera and microphone access granted');
            updateStatus('connected', 'Connected');
        } catch (error) {
            addDebugInfo(`Error accessing media devices: ${error.message}`);
            showNotification('Error: Could not access camera or microphone', 'error');
            updateStatus('error', 'Media Error');
        }
    }

    // Connect to WebSocket with better error handling
    function connectWebSocket() {
        addDebugInfo('Attempting WebSocket connection...');

        // WebSocket endpoints with base URL
        const endpoints = [
            `${BASE_URL}/pair-video`,  // Primary endpoint through gateway
            '/pair-video',             // Fallback direct endpoint
            '/ws',
            '/videocall/ws'
        ];

        let currentEndpointIndex = 0;

        function tryConnect() {
            if (currentEndpointIndex >= endpoints.length) {
                addDebugInfo('All WebSocket endpoints failed');
                showNotification('Connection error. Please refresh the page.', 'error');
                return;
            }

            const endpoint = endpoints[currentEndpointIndex];
            addDebugInfo(`Trying WebSocket endpoint: ${endpoint}`);

            try {
                const socket = new SockJS(endpoint);
                stompClient = Stomp.over(socket);

                // Disable heartbeats for better debugging
                stompClient.heartbeat.outgoing = 0;
                stompClient.heartbeat.incoming = 0;

                stompClient.connect({}, function(frame) {
                    addDebugInfo(`WebSocket connected successfully to ${endpoint}`);
                    addDebugInfo(`Connection frame: ${frame}`);

                    updateStatus('connected', 'Connected');

                    // Subscribe to private messages
                    const subscriptionPath = `/content/user/${userId}`;
                    addDebugInfo(`Subscribing to: ${subscriptionPath}`);

                    stompClient.subscribe(subscriptionPath, function(message) {
                        addDebugInfo(`Received message: ${message.body}`);
                        handleWebSocketMessage(JSON.parse(message.body));
                    });

                    // Request a partner
                    requestPartner();

                }, function(error) {
                    addDebugInfo(`WebSocket connection failed for ${endpoint}: ${error}`);
                    currentEndpointIndex++;
                    setTimeout(tryConnect, 1000);
                });

            } catch (error) {
                addDebugInfo(`Error creating WebSocket for ${endpoint}: ${error}`);
                currentEndpointIndex++;
                setTimeout(tryConnect, 1000);
            }
        }

        tryConnect();
    }

    // Handle WebSocket messages
    function handleWebSocketMessage(message) {
        addDebugInfo(`Processing message type: ${message.type}`);

        switch(message.type) {
            case 'PAIR_CONNECTED':
                handlePairConnected(message);
                break;
            case 'PAIR_DISCONNECTED':
                handlePairDisconnected(message);
                break;
            case 'offer':
                handleOffer(message);
                break;
            case 'answer':
                handleAnswer(message);
                break;
            case 'candidate':
                handleCandidate(message);
                break;
            default:
                addDebugInfo(`Unknown message type: ${message.type}`);
        }
    }

    // Handle pairing with a partner
    function handlePairConnected(message) {
        partnerId = message.pairedUserId;
        const partnerName = message.pairedUserName;

        addDebugInfo(`Paired with partner: ${partnerName} (ID: ${partnerId})`);

        updateStatus('connected', `Connected to ${partnerName}`);
        connectionMessage.innerHTML = `Connected with <strong>${partnerName}</strong>`;

        // Enable skip button
        skipBtn.disabled = false;

        showNotification(`Connected with ${partnerName}`, 'success');

        // Initialize WebRTC connection
        initializeWebRTC();
    }

    // Handle partner disconnection
    function handlePairDisconnected(message) {
        const disconnectedUserId = message.disconnectedUserId;

        addDebugInfo(`Partner disconnected: ${disconnectedUserId}`);

        updateStatus('connected', 'Partner disconnected');
        connectionMessage.innerHTML = 'Partner disconnected. Looking for a new partner...';

        // Disable skip button
        skipBtn.disabled = true;

        showNotification('Partner disconnected', 'info');

        // Reset WebRTC
        resetWebRTC();

        // Request a new partner
        requestPartner();
    }

    // Initialize WebRTC connection
    function initializeWebRTC() {
        addDebugInfo('Initializing WebRTC connection');

        try {
            peerConnection = new RTCPeerConnection(configuration);

            // Add local stream to connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Set up remote stream
            remoteStream = new MediaStream();
            remoteVideo.srcObject = remoteStream;

            // Listen for remote tracks
            peerConnection.ontrack = event => {
                addDebugInfo('Remote track received');
                event.streams[0].getTracks().forEach(track => {
                    remoteStream.addTrack(track);
                });
            };

            // Listen for ICE candidates
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    addDebugInfo('Sending ICE candidate');
                    sendSignalMessage({
                        type: 'candidate',
                        from: userId,
                        to: partnerId,
                        candidate: event.candidate
                    });
                }
            };

            // If we're the caller, create an offer
            if (isCaller) {
                createOffer();
            }

            addDebugInfo('WebRTC connection initialized');
        } catch (error) {
            addDebugInfo(`WebRTC initialization error: ${error.message}`);
        }
    }

    // Create WebRTC offer
    async function createOffer() {
        try {
            addDebugInfo('Creating WebRTC offer');
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);

            sendSignalMessage({
                type: 'offer',
                from: userId,
                to: partnerId,
                sdp: offer.sdp
            });
            addDebugInfo('WebRTC offer sent');
        } catch (error) {
            addDebugInfo(`Error creating offer: ${error.message}`);
        }
    }

    // Handle incoming offer
    async function handleOffer(message) {
        addDebugInfo('Handling incoming WebRTC offer');
        if (!peerConnection) {
            initializeWebRTC();
        }

        try {
            await peerConnection.setRemoteDescription({
                type: 'offer',
                sdp: message.sdp
            });

            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            sendSignalMessage({
                type: 'answer',
                from: userId,
                to: partnerId,
                sdp: answer.sdp
            });
            addDebugInfo('WebRTC answer sent');
        } catch (error) {
            addDebugInfo(`Error handling offer: ${error.message}`);
        }
    }

    // Handle incoming answer
    async function handleAnswer(message) {
        addDebugInfo('Handling incoming WebRTC answer');
        try {
            await peerConnection.setRemoteDescription({
                type: 'answer',
                sdp: message.sdp
            });
            addDebugInfo('WebRTC answer processed');
        } catch (error) {
            addDebugInfo(`Error handling answer: ${error.message}`);
        }
    }

    // Handle incoming ICE candidate
    async function handleCandidate(message) {
        addDebugInfo('Handling incoming ICE candidate');
        try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
            addDebugInfo('ICE candidate processed');
        } catch (error) {
            addDebugInfo(`Error handling ICE candidate: ${error.message}`);
        }
    }

    // Send signal message via WebSocket - UPDATED WITH BASE_URL
    function sendSignalMessage(message) {
        if (stompClient && stompClient.connected) {
            const destination = `${BASE_URL}/application/signalmessage.send`;
            addDebugInfo(`Sending message to ${destination}: ${JSON.stringify(message)}`);
            stompClient.send(destination, {}, JSON.stringify(message));
        } else {
            addDebugInfo('Cannot send message: WebSocket not connected');
        }
    }

    // Request a partner
    function requestPartner() {
        const url = `${BASE_URL}/next/${userId}`;
        addDebugInfo(`Requesting partner from: ${url}`);

        fetch(url, {
            method: 'POST',
            credentials: 'include'
        })
        .then(response => {
            addDebugInfo(`Partner request response status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            addDebugInfo(`Partner request response: ${JSON.stringify(data)}`);

            if (data.partnerId) {
                partnerId = data.partnerId;
                isCaller = true;

                updateStatus('connected', 'Partner found');
                connectionMessage.innerHTML = 'Partner found. Establishing connection...';
                skipBtn.disabled = false;
            } else {
                updateStatus('connected', 'Waiting for partner');
                connectionMessage.innerHTML = `
                    <div class="waiting-animation">
                        <span>Looking for a partner</span>
                        <div class="dots">
                            <div class="dot"></div>
                            <div class="dot"></div>
                            <div class="dot"></div>
                        </div>
                    </div>
                `;
                skipBtn.disabled = true;
            }
        })
        .catch(error => {
            addDebugInfo(`Error requesting partner: ${error.message}`);
            showNotification('Error connecting to server', 'error');
        });
    }

    // Update connection status
    function updateStatus(status, text) {
        connectionStatus.className = 'status-dot ' + status;
        statusText.textContent = text;
    }

    // Show notification
    function showNotification(message, type) {
        notification.textContent = message;
        notification.className = `notification ${type}`;
        notification.classList.add('show');

        setTimeout(() => {
            notification.classList.remove('show');
        }, 3000);
    }

    // Set up event listeners
    function setupEventListeners() {
        nextBtn.addEventListener('click', function() {
            addDebugInfo('Next button clicked');
            skipPartner();
        });

        skipBtn.addEventListener('click', function() {
            addDebugInfo('Skip button clicked');
            skipPartner();
        });
    }

    // Skip current partner
    function skipPartner() {
        if (partnerId) {
            const url = `${BASE_URL}/skip/${userId}`;
            addDebugInfo(`Skipping partner via: ${url}`);

            fetch(url, {
                method: 'POST',
                credentials: 'include'
            })
            .then(response => {
                addDebugInfo(`Skip response status: ${response.status}`);
                if (response.ok) {
                    resetWebRTC();
                    requestPartner();
                    showNotification('Skipped current partner', 'info');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            })
            .catch(error => {
                addDebugInfo(`Error skipping partner: ${error.message}`);
                showNotification('Error skipping partner', 'error');
            });
        }
    }

    // Reset WebRTC connection
    function resetWebRTC() {
        addDebugInfo('Resetting WebRTC connection');
        if (peerConnection) {
            peerConnection.close();
            peerConnection = null;
        }

        if (remoteStream) {
            remoteStream.getTracks().forEach(track => track.stop());
            remoteVideo.srcObject = null;
        }

        partnerId = null;
        isCaller = false;
    }

    // Handle page unload
    window.addEventListener('beforeunload', function() {
        addDebugInfo('Page unloading, cleaning up...');
        if (partnerId) {
            fetch(`${BASE_URL}/skip/${userId}`, {
                method: 'POST',
                credentials: 'include',
                keepalive: true
            });
        }

        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }

        if (remoteStream) {
            remoteStream.getTracks().forEach(track => track.stop());
        }

        if (peerConnection) {
            peerConnection.close();
        }

        if (stompClient) {
            stompClient.disconnect();
        }
    });
</script>

<!-- Include SockJS and Stomp libraries -->
<script src="https://cdn.jsdelivr.net/npm/sockjs-client@1.5.0/dist/sockjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/stompjs@2.3.3/lib/stomp.min.js"></script>
</body>
</html>